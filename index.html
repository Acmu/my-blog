<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MingYuan&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="明远博客 MingYuan&#39;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="MingYuan&#39;s Blog">
<meta property="og:url" content="https://acmu.github.io/index.html">
<meta property="og:site_name" content="MingYuan&#39;s Blog">
<meta property="og:description" content="明远博客 MingYuan&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MingYuan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/my-blog/atom.xml" title="MingYuan's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/my-blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/my-blog/css/style.css">

  
    
<link rel="stylesheet" href="/my-blog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/my-blog/" id="logo">MingYuan&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/my-blog/" id="subtitle">明远博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/my-blog/">Home</a>
        
          <a class="main-nav-link" href="/my-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/my-blog/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://acmu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JavaScript/kind-of源码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/11/16/JavaScript/kind-of%E6%BA%90%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2022-11-16T23:12:20.000Z" itemprop="datePublished">2022-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/11/16/JavaScript/kind-of%E6%BA%90%E7%A0%81/">周下载量超1亿的库是如何判断JS类型的？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近我偶然发现了一个库：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/kind-of">kind-of</a>，他的作用是判断 JS 数据类型，经常被一些基础库所使用，如 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/clone-deep">clone-deep</a> 等，周下载量超 1 亿。</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-11/16_18:20_GtoHmO.png" alt="image-2022111662009862 PM"></p>
<p>如何判断 JS 数据类型也是一道常见面试题，本文就来看看 kind-of 是如何解决的。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kindOf(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//=&gt; &#x27;null&#x27;</span></span><br><span class="line"></span><br><span class="line">kindOf(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//=&gt; &#x27;boolean&#x27;</span></span><br><span class="line"></span><br><span class="line">kindOf(<span class="keyword">new</span> <span class="built_in">WeakMap</span>());</span><br><span class="line"><span class="comment">//=&gt; &#x27;weakmap&#x27;</span></span><br><span class="line"></span><br><span class="line">kindOf(<span class="keyword">new</span> <span class="built_in">Set</span>());</span><br><span class="line"><span class="comment">//=&gt; &#x27;set&#x27;</span></span><br><span class="line"></span><br><span class="line">kindOf(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>());</span><br><span class="line"><span class="comment">//=&gt; &#x27;uint8array&#x27;</span></span><br></pre></td></tr></table></figure>

<p>传入对应类型数据，调用就会返回对应字符串。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>由于源码简单，我们直接打开 <a target="_blank" rel="noopener" href="https://unpkg.com/kind-of">https://unpkg.com/kind-of</a> 就能看到源码（这里看到的代码和你使用 npm 安装后的代码是一样的）。觉得太长的，可以先略过代码，直接去看下面的分析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">kindOf</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> val;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;boolean&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;symbol&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isGeneratorFn(val) ? <span class="string">&#x27;generatorfunction&#x27;</span> : <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(val)) <span class="keyword">return</span> <span class="string">&#x27;array&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isBuffer(val)) <span class="keyword">return</span> <span class="string">&#x27;buffer&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isArguments(val)) <span class="keyword">return</span> <span class="string">&#x27;arguments&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isDate(val)) <span class="keyword">return</span> <span class="string">&#x27;date&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isError(val)) <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isRegexp(val)) <span class="keyword">return</span> <span class="string">&#x27;regexp&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ctorName(val)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Symbol&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Promise&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;promise&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set, Map, WeakSet, WeakMap</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;WeakMap&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;weakmap&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;WeakSet&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;weakset&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Map&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;map&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Set&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;set&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8-bit typed arrays</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Int8Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;int8array&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Uint8Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;uint8array&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Uint8ClampedArray&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;uint8clampedarray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 16-bit typed arrays</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Int16Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;int16array&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Uint16Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;uint16array&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 32-bit typed arrays</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Int32Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;int32array&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Uint32Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;uint32array&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Float32Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;float32array&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Float64Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;float64array&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isGeneratorObj(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;generator&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-plain objects</span></span><br><span class="line">    type = toString.call(val);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[object Object]&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line">        <span class="comment">// iterators</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[object Map Iterator]&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;mapiterator&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[object Set Iterator]&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;setiterator&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[object String Iterator]&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;stringiterator&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[object Array Iterator]&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;arrayiterator&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other</span></span><br><span class="line">    <span class="keyword">return</span> type.slice(<span class="number">8</span>, -<span class="number">1</span>).toLowerCase().replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ctorName</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val.constructor === <span class="string">&#x27;function&#x27;</span> ? val.constructor.name : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray) <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">    <span class="keyword">return</span> val <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isError</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        val <span class="keyword">instanceof</span> <span class="built_in">Error</span> ||</span><br><span class="line">        (<span class="keyword">typeof</span> val.message === <span class="string">&#x27;string&#x27;</span> &amp;&amp;</span><br><span class="line">            val.constructor &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> val.constructor.stackTraceLimit === <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDate</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="keyword">typeof</span> val.toDateString === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> val.getDate === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> val.setDate === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRegexp</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="keyword">typeof</span> val.flags === <span class="string">&#x27;string&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> val.ignoreCase === <span class="string">&#x27;boolean&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> val.multiline === <span class="string">&#x27;boolean&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> val.global === <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isGeneratorFn</span>(<span class="params">name, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctorName(name) === <span class="string">&#x27;GeneratorFunction&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isGeneratorObj</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="keyword">typeof</span> val.throw === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> val.return === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> val.next === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArguments</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="keyword">typeof</span> val.length === <span class="string">&#x27;number&#x27;</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> val.callee === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err.message.indexOf(<span class="string">&#x27;callee&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If you need to support Safari 5-7 (8-10 yr-old browser),</span></span><br><span class="line"><span class="comment"> * take a look at https://github.com/feross/is-buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBuffer</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val.constructor &amp;&amp; <span class="keyword">typeof</span> val.constructor.isBuffer === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> val.constructor.isBuffer(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意这是使用了 <code>module.exports</code> 即 CJS 的模式，可在 node 中直接使用，但不能在浏览器中使用。</p>
<p>入口是 kindOf 函数，大致过程：</p>
<ol>
<li>用 <code>===</code> 比较出了 null 和 undefined（用 void 0 表示 undefined 更准确，因为 undefined 是变量，值可以被改变）</li>
<li>用 <code>typeof</code> 比较出了 boolean、string、number、symbol</li>
<li>如果 <code>typeof</code> 值是函数<ol>
<li>判断生成器函数 generatorfunction（通过构造函数名是否为 GeneratorFunction 判断）</li>
<li>否则是普通函数 function</li>
</ol>
</li>
<li>通过自定义函数判断出 array、buffer、arguments、date、error、regexp 类型<ol>
<li>array：通过 Array.isArray 和 原型链继承 Array 判断</li>
<li>buffer：构造函数上的 isBuffer 方法</li>
<li>arguments：lenth 属性和 callee 方法</li>
<li>date：原型链继承 Date 或 拥有 toDateString、getDate、setDate 方法</li>
<li>error：原型链继承 Error 或拥有 message 属性和构造函数上的 stackTraceLimit 属性</li>
<li>regexp：原型链继承 Error 或拥有特定属性或方法（拥有了特定属性或方法，就判断它为一个类型是不严谨的，但这里也只是兜底逻辑，并且也是符合鸭子类型的思想的）</li>
</ol>
</li>
<li>通过构造函数的命名判断出了 promise、map、set、int8array 等类型</li>
<li>通过 <code>Object.prototype.toString.call(val)</code> 判断 setiterator 等</li>
<li>最后兜底逻辑是返回 toString 的类型值</li>
</ol>
<p>看下来是比较简单的，主要使用了 4 中方法判断类型：</p>
<ol>
<li> <code>===</code></li>
<li> <code>typeof</code></li>
<li> 原型链继承 <code>instanceof</code></li>
<li> 鸭子类型法（只要有这些属性或方法，就是某种类型）</li>
<li> <code>Object.prototype.toString.call(val)</code></li>
</ol>
<p>弄懂了这个库也就对 JS 的类型更深入了，以后判断类型的时候也可以直接使用此库了。</p>
<p>类似功能的还有 <a target="_blank" rel="noopener" href="https://github.com/CodingFu/typeof">typeof</a> 和 <a target="_blank" rel="noopener" href="https://github.com/ForbesLindesay/type-of">type-of</a> 等，kind-of 相比于他们的优势是类型检测更全面以及性能更好。</p>
<p>其实我们应该多多去了解这些很常用基础库的使用与原理，这既可以解决通用问题，也可以拓展知识面。比如 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/is-primitive">is-primitive</a>、<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/is-number">is-number</a> 等等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/11/16/JavaScript/kind-of%E6%BA%90%E7%A0%81/" data-id="clf0n06s0001gb2of7mii673u" data-title="周下载量超1亿的库是如何判断JS类型的？" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-weekly/10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/11/10/weekly/10/" class="article-date">
  <time class="dt-published" datetime="2022-11-10T23:12:20.000Z" itemprop="datePublished">2022-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/11/10/weekly/10/">明远视角：前端脚手架开发入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>👀 本期看点：</p>
<ul>
<li>  前端脚手架开发入门</li>
<li>  Puppeteer 原理分析</li>
<li>  pnpm 对比 npm 与 yarn</li>
<li>  JS 实现私有属性</li>
<li>  npm 并行执行脚本</li>
<li>  glob 语法介绍</li>
<li>  循环依赖时，CJS 与 ESM 的区别</li>
</ul>
<h2 id="📃-文章"><a href="#📃-文章" class="headerlink" title="📃 文章"></a>📃 文章</h2><p>👉 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/oFo43lbfdueVcdaOlJQ_tg">前端脚手架开发入门</a></p>
<p>我们常常陷于业务开发，拿起脚手架就开干，但脚手架到底做了什么，你了解吗？本文介绍了一些工具，如：commander、chalk、inquirer、ora 等，以及 package.json 中的一些重要字段，最后通过实例 demo 来展示如何开发脚手架，是一篇入门好文。</p>
<p>👉 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9YKQcxtsneW2LzaddKim9Q">手写 Puppeteer：远程控制 Chromium</a></p>
<p>Puppeteer 相信大家都听过，它可以用 JS 自动化控制浏览器，本文讲述了其原理，基于 Chrome DevTools Protocol，它是 chrome devtools 和 chromium 通信的协议。</p>
<p>（直接下载 puppeteer 包很耗时，因为会同时下载 chromium，你可以下载 puppeteer-core 包，之后配置 <code>executablePath</code> 字段，类似<code>executablePath: &#39;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#39;,</code>，这样就可以控制你电脑的 Chrome 了，会节省很多时间）</p>
<p>👉 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/bLthdXlmu8wtC3ScAaZ3Kg">pnpm 是凭什么对 npm 和 yarn 降维打击的</a></p>
<p>npm v2 是 嵌套 node_modules， 问题：</p>
<ol>
<li>重复的包安装了多次</li>
<li>windows 下路径名最长 200 多个字符，大于他会出错</li>
</ol>
<p>yarn 出来了（npm v3 也紧跟），解决方案：铺平 node_modules，但有新的问题：幽灵包（没有安装包，但是可以用）、同一个包的不同版本还是会重复安装。最后 pnpm 出来了，使用链接解决，比较完美。</p>
<p>👉 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SusZu6rdVijZ-6seg9oa0Q">私有属性的 6 种实现方式，你用过几种？</a></p>
<p>私有属性在 Java 的实现及其简单，但在 JS 中的实现可谓是眼花缭乱。本文总结了 6 种实现方式，并且分析了利弊。</p>
<ol>
<li>下划线命名</li>
<li>下划线加 Proxy 限制</li>
<li>基于 Symbol 特性</li>
<li>使用 WeakMap</li>
<li>ES 最新草案 #prop</li>
<li>TS 的 private</li>
</ol>
<p>👉 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7111118506657218590">npm-run-all 并行执行脚本</a></p>
<p>有些 npm 脚本没有必要串行，比如<code>build:umd</code> 和 <code>build:esm</code>，它们没有依赖关系，所以可并行执行。本文介绍可以通过<code>npm-run-all</code>包来帮助开发者并行执行脚本。</p>
<p>👉 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4LvZlT6ZT-OV0699XREfLg"><code>**/*.js</code> 是啥语法？谁能解析？</a></p>
<p><code>.gitignore</code> 里、<code>webpack</code> 配置里等这种配置<code>**/*.js</code>、<code>dist/**/package.json</code>，叫做 glob 语法，它来源于 linux，允许使用者通过 “通配符” 来匹配目录和文件。因为其 “实用、好用”，所以渐渐出圈，因此，即便我们使用的是 <code>windows</code>，在前端项目里也有工具库可以轻松的解析这种语法。</p>
<p>👉 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JSlJn_LzbkAOy6LNyY5_jQ">抖音二面：为什么模块循环依赖不会死循环？CommonJS 和 ES Module 的处理有什么不同？</a></p>
<p>本文给出多个循环依赖的实例，并且包含 CJS 和 ESM 的对比，由浅入深的分析了现象与本质。</p>
<h2 id="🤔-想法"><a href="#🤔-想法" class="headerlink" title="🤔 想法"></a>🤔 想法</h2><ol>
<li><p>我们在项目初期都会思考几个问题：客户是谁？解决什么问题？使用什么技术方案？带来什么价值？这几个问题思考下来，项目要不要做、怎么做，基本就清晰了。来自：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MMCO_vU_XE783XvxFTvfDQ">大淘宝技术人金句</a>。</p>
<ol>
<li>不要过于看重技术，它一定要基于场景，并且能解决问题，才能发挥作用。</li>
</ol>
</li>
<li><p>近期裁员很多，周围有的同事也已离开，所以需要多多提升自己了。</p>
<ol>
<li>疫情这几年裁员已经比较平常了，我越来越意识到：不要认为是自己能力不行所以被裁，只不过就是公司的业务调整罢了，真的代表不了什么，更多是运气的成分吧。</li>
</ol>
</li>
<li><p>周刊改名为视角了，因为发现不可能每周更新，又叫周刊就有些奇怪 😂。更新速度会放慢，因为高质量的文章比较少，而且文章相关联的知识也要去学习。</p>
</li>
</ol>
<p><em>2022-11-10（第 10 期）</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/11/10/weekly/10/" data-id="clf0n06sy003db2of8699dja2" data-title="明远视角：前端脚手架开发入门" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/%E5%91%A8%E5%88%8A/" rel="tag">周刊</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/使用 npm link 调试包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/11/09/JavaScript/%E4%BD%BF%E7%94%A8%20npm%20link%20%E8%B0%83%E8%AF%95%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2022-11-09T23:12:20.000Z" itemprop="datePublished">2022-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/11/09/JavaScript/%E4%BD%BF%E7%94%A8%20npm%20link%20%E8%B0%83%E8%AF%95%E5%8C%85/">使用 npm link 调试包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文讨论的是 npm v6 版本。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我要调试的包是 mc-charts，主工程是 tms-c3，即我要都 tms-c3 中使用 npm link 调试 mc-charts 包。</p>
<p>共两步：</p>
<ol>
<li>在 mc-charts 包执行 npm link。</li>
<li>在 tms-c3 中执行 npm link mc-charts（注意：这里一定是包名，即 package.json 中的 name 字段，而不是文件目录名）。</li>
</ol>
<p>以下实际演示一遍：</p>
<p>第一步：进入 mc-charts 包目录下（路径是/Users/yuan/repo/mc-charts），他的 package.json 的 name 字段是 mc-charts，这时我在此包下执行 npm link：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/node_modules/mc-charts -&gt; /Users/yuan/repo/mc-charts</span><br></pre></td></tr></table></figure>

<p>输出内容表示在 /usr/local/lib/node_modules 目录下新建了一个软链接，指向了 mc-charts 包的目录</p>
<p>第二步：在主工程是 tms-c3 （路径是/Users/yuan/repo/tms-c3）中执行 npm link mc-charts</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Users/yuan/repo/tms-c3/node_modules/mc-charts</span><br><span class="line">-&gt; /usr/local/lib/node_modules/mc-charts</span><br><span class="line">-&gt; /Users/yuan/repo/mc-charts</span><br></pre></td></tr></table></figure>

<p>为了方便展示，进行了换行。这里表示在主工程 tms-c3 的 node_modules 下新建了一个软链接，他指向了 /usr/local/lib/node_modules/mc-charts，但此时 /usr/local/lib/node_modules/mc-charts 又指向了 /Users/yuan/repo/mc-charts，所以就能达到调试的目的。</p>
<h2 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h2><p>还有简化版本：npm link pkgFloder（包的路径地址）</p>
<p>tms-c3 目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link ../mc-charts/</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/node_modules/mc-charts -&gt; /Users/yuan/repo/mc-charts</span><br><span class="line"></span><br><span class="line">/Users/yuan/repo/tms-c3/node_modules/mc-charts</span><br><span class="line">-&gt; /usr/local/lib/node_modules/mc-charts</span><br><span class="line">-&gt; /Users/yuan/repo/mc-charts</span><br></pre></td></tr></table></figure>

<p>这时你项目的 node_modules 中就已经有了 mc-charts 包了，首先在 package.json 里的 dependencies 加上 mc-charts 包，版本随便写就行，最后在代码中 import 即可使用了。如果你有 watch 文件变更的需求，npm link 也是支持的。</p>
<h2 id="删除-link"><a href="#删除-link" class="headerlink" title="删除 link"></a>删除 link</h2><p>如果要取消 link，直接删除 <code>/Users/yuan/repo/tms-c3/node_modules/mc-charts</code> 和 <code>/usr/local/lib/node_modules/mc-charts</code> 这两个文件即可，或者可以使用 npm unlink 命令（网络上说 unlink 命令可行，但我并没有在 npm 官方文档找到此命令）</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/electricg/68f1d42e29a322b5f3bc34748bac1f8e">npm unlink 命令参考</a>：</p>
<p>Link scoped pakcages:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/projects/node-redis    # go into the scoped package directory</span><br><span class="line">npm link                    # creates global link</span><br><span class="line">cd ~/projects/node-bloggy   # go into some other package directory</span><br><span class="line">npm link @myorg/redis       # link-install the scoped package</span><br></pre></td></tr></table></figure>

<p>Unlink scoped packages:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~/projects/node-bloggy  # go into some other package directory</span><br><span class="line">npm unlink @myorg/redis    # unlink-uninstall the scoped package</span><br><span class="line">npm install @myorg/redis   # re-install the scoped package</span><br><span class="line">cd ~/projects/node-redis   # go into the scoped package directory</span><br><span class="line">npm unlink                 # deletes global link</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果你了解软链接与硬链接，那么可以轻松的猜到：link 命令就是创建的软链接而已，我们可以自己使用 shell 的 ln 命令实现。</p>
<p>为什么只是创建了软链接就能调试包了呢？这还要看 node 的查包逻辑了，你 import 了 mc-charts 包，它会先去 node_modules 中找，找到的刚好是软链接，所以就能调试了。</p>
<p>参考：</p>
<p>npm link 命令 v6 版本<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v6/commands/npm-link">使用文档</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/11/09/JavaScript/%E4%BD%BF%E7%94%A8%20npm%20link%20%E8%B0%83%E8%AF%95%E5%8C%85/" data-id="clf0n06s8001nb2of0xl4auot" data-title="使用 npm link 调试包" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/JavaScript 的对象与继承" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/11/05/JavaScript/JavaScript%20%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%A7%E6%89%BF/" class="article-date">
  <time class="dt-published" datetime="2022-11-05T09:19:02.000Z" itemprop="datePublished">2022-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/11/05/JavaScript/JavaScript%20%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%A7%E6%89%BF/">JavaScript 的对象与继承</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文来自一次组内分享。</p>
<p>对象和继承一直都是 JavaScript 里重要的概念，JavaScript 也是一门被误解的语言，尤其是在继承方面，本文就带大家更深入的了解对象与继承的相关知识。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是 JavaScript 中的一种数据类型（为什么 Array RegExp 等等，不是数据类型呢？），对象由属性和属性值组成，属性的类型只能是字符串或 Symbol，属性又分为两种类型，数据属性 和 访问器属性，每个属性都有 4 个描述符</p>
<p>数据属性 和 访问器属性 共同的描述符：</p>
<ol>
<li>[[Configurable]]：属性是否可以通过 delete 删除，是否可以修改它的描述符，以及是否可以在数据属性与访问器属性之间切换</li>
<li>[[Enumerable]]：是否 for in 循环、Object.keys() 可访问</li>
</ol>
<p>不同的描述符：</p>
<p>数据属性：</p>
<ol>
<li>[[Value]]：属性值</li>
<li>[[Writable]]：是否可以修改 [[Value]]</li>
</ol>
<p>访问器属性：</p>
<ol>
<li>[[Get]]：获取函数，在读取属性时调用</li>
<li>[[Set]]：设置函数，在写入属性时调用</li>
</ol>
<p>[[xxx]] 这种双中括号代表什么？类似的还有 @@toPrimitive 又代表什么？</p>
<ol>
<li>[[xxx]] 这种双中括号的表示一般在规范文档中，代表是引擎的内部属性</li>
<li>@@toPrimitive 这种类似表示，代表的是 Symbol.hasInstance</li>
</ol>
<p>可使用 Object.defineProperty() 与 Object.getOwnPropertyDescriptor() 设置与获取属性的描述符，默认我们直接对象定义的，都是 true 是数据属性：</p>
<p>以下两种表示是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj2, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>还可以用这样简写的方式定义访问器属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种控制台显示 … 的就是计算属性，点击之后会调用 getter</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-11/05_09:10_5GpVXc.png" alt="image-2022110591023096 AM"></p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用字面量直接定义属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ming&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.introduce()</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>当你要定义多个对象的时候，直接复制多个还是有些麻烦，所以可以写一个工厂函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = createPerson(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = createPerson(<span class="string">&#x27;foo&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">p2.introduce();</span><br></pre></td></tr></table></figure>

<p>此模式的问题是无法使用 instanceof 等判断对象的类型</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数就是一个普通函数，只不过一般约定构造函数的首字母是大写的，以及它只会和 new 搭配使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">p1.introduce();</span><br></pre></td></tr></table></figure>

<p>它模仿了 Java 的写法，这里和 createPerson 的区别是：</p>
<ol>
<li>没有 return。</li>
<li>属性和方法直接赋值给了 this。</li>
<li>没有显式地创建对象。</li>
</ol>
<p>如果想要继续深入继承部分的内容，那么这里就要深入理解下：</p>
<ol>
<li><p>这应该是个很明显的约定，构造函数是不应该 return 的，如果 return 了那不就回到了工厂模式嘛</p>
</li>
<li><p>this 是很微妙的存在，如果没有 this 会怎样？</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ming&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有 this，这里只能使用 person</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + person.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里不能复用，只能是一个新的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + animal.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没有显式地创建对象，那对象哪里来的？是 new “惹的祸”，new 干了什么？想要知道这个，你就得先了解原型链</p>
<h3 id="原型链机制"><a href="#原型链机制" class="headerlink" title="原型链机制"></a><strong>原型链机制</strong></h3><p>如下代码的输出是什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.x);</span><br></pre></td></tr></table></figure>

<p>解释：没有在对象上定义 x 属性，但为什么能获取到呢？因为<strong>对象在获取属性时，如果当前的对象没有，那么就会向当前对象的原型对象去寻找，如果还没有就继续向原型对象寻找，直到没有原型对象为止。</strong>这就是原型链，根据原型为链条寻找属性的机制。代码中的 <strong>proto</strong> 属性就是这里说的原型</p>
<h4 id="proto-vs-Prototype-vs-prototype"><a href="#proto-vs-Prototype-vs-prototype" class="headerlink" title="proto vs [[Prototype]] vs prototype"></a><strong>proto</strong> vs [[Prototype]] vs prototype</h4><ol>
<li><strong>proto</strong> 属性：每个对象都有此属性，代表原型，是非标准的历史遗留属性，现在并不推荐使用</li>
<li>[[Prototype]] 内部属性：每个对象都有此属性，代表原型，是ES规范中的描述，和 <strong>proto</strong> 属性 功能完全一样，更推荐现代语法使用，但内部属性是不能直接在 JavaScript 语言层面访问的，还好语言标准提供了 Object.getPrototypeOf() 和 Object.setPrototypeOf() 获取和设置原型</li>
<li>prototype 属性：每个函数都有 prototype 属性，他只有在此函数作为构造函数时才有意义，下文会讲</li>
</ol>
<h4 id="原型链图示"><a href="#原型链图示" class="headerlink" title="原型链图示"></a>原型链图示</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj, obj2);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-11/05_09:13_7fWFTR.png" alt="image-2022110591310248 AM"></p>
<p>可以看到如上代码设置了原型对象的对象，会比普通对象中间多一层</p>
<h3 id="new-干了什么"><a href="#new-干了什么" class="headerlink" title="new 干了什么"></a>new 干了什么</h3><p>知道了原型链机制，那么现在就可以分析 new 干了什么</p>
<ol>
<li>创建一个新对象 foo</li>
<li>将新对象 foo 的 [[Prototype]] 内部属性赋值为构造函数的 prototype 属性</li>
<li>使用新对象 foo 的上下文执行构造函数（即构造函数中的this会指向新对象，并为这个新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回构造函数返回的对象；否则，返回新对象  foo</li>
</ol>
<p><strong>这里很重要，下面还会继续用</strong>，要理解好。构造函数的 prototype 属性，这是什么呢？没事，我们可以先暂时略过这条，后面再看</p>
<p>知道了原理，可以先忽略第2条，实现一个自己的 new，其实很简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里为了保持简单，省略了构造函数有返回值的情况，因为这种情况也并不常见</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fun, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">  fun.apply(foo, args);</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">p1.introduce();</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里为了保持简单，省略了构造函数有返回值的情况，因为这种情况也并不常见</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fun, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">  fun.apply(foo, args);</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = myNew(Person, <span class="string">&#x27;ming2&#x27;</span>, <span class="number">25</span>)</span><br><span class="line">p2.introduce()</span><br><span class="line"><span class="built_in">console</span>.log(p2)</span><br></pre></td></tr></table></figure>

<p>（此时的 myNew 并不完整，后文还会再补充）</p>
<p>接下来说回构造函数创建对象，其实此模式也存在问题：其定义的方法会在每个实例都创建一遍，不能复用（联想到大鹏分享的，冗余占用了内存呀）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming3&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个实例都有一个自己的 introduce 函数</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.introduce === p3.introduce);</span><br></pre></td></tr></table></figure>

<p>那聪明的你就想到了，我们不用每次都新生成一个函数呀，可以用同一个函数的引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">introduce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.introduce = introduce;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming3&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.introduce === p3.introduce);</span><br></pre></td></tr></table></figure>

<p>这的确是个好办完，但唯一的缺点就是 introduce 占用了全局的命名空间，但解决这个问题也简单，只要把 introduce 等等众多方法放到 一个对象 myFuncs 中就行了，但是 myFuncs 也占用了一个全局的命名空间呀，那就不把 myFuncs 放在全局命名空间中了，那放在那里好呢？此时你想到函数也是对象呀，那么可以在函数上面添加属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.introduce = Person.myFuncs.introduce;</span><br><span class="line">&#125;</span><br><span class="line">Person.myFuncs = &#123;</span><br><span class="line">  <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming3&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.introduce === p3.introduce);</span><br></pre></td></tr></table></figure>


<p>但每次都这样写有些麻烦，还能不能更简略些？可以的，语言层面已经帮你实现了</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>不用你写函数的 myFuncs 属性了，语言规定，每个函数都有一个 prototype 属性（对就是上文说道的），他就是我们的 myFuncs 属性，只是换了个名字而已，还带有两个特殊逻辑：</p>
<ol>
<li><p>prototype 属性值是一个对象，对象中有一个 constructor 属性，属性值是构造函数<br>这个 constructor 属性到底有什么用呢？🧐</p>
<p>我在看了半天 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor#browser_compatibility">mdn</a> 后得出结论：它没什么用 😅。</p>
<p>它有一个比较常见的用法是用于判断对象的类型，但它很容易被赋值或删除，相比于 instanceof 和 Symbol.toStringTag 来说并不可靠，其实这两个也并非绝对可靠。</p>
<p>这里说的 Symbol.toStringTag 是什么？</p>
</li>
<li><p>这里就是上文说的暂时忽略的第2条：在执行 new 的时候，会『把新对象 foo 的 [[Prototype]] 内部属性赋值为构造函数的 prototype 属性』，这样由于原型机制，我们也不用多余执行 this.introduce = Person.myFuncs.introduce 这段代码了，但是要记得把 Person.prototype.introduce 赋值</p>
</li>
</ol>
<p>故可以得出如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming3&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.introduce === p3.introduce);</span><br></pre></td></tr></table></figure>

<p>这样的代码你是不是在哪里见过？</p>
<p>如 Vue 2 的插件模式。你也可以自己写个好玩的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.test = <span class="string">&#x27;haha&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样每个对象的原型上都有了 test 属性</p>
<p>这里发现，上文的 myNew 实现并不完整，应补充 [[Prototype]] 内部属性赋值的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">p1.introduce();</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fun, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(foo, fun.prototype);</span><br><span class="line">  fun.apply(foo, args);</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = myNew(Person, <span class="string">&#x27;ming2&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">p2.introduce();</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br></pre></td></tr></table></figure>

<p>这里与上文相比，还有个改动就是 introduce 等方法不是实例属性了，而是原型属性（即多个实例会用相同的原型），实例属性与原型属性有什么区别？</p>
<p>注意：如果你看过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">setPrototypeOf 的 mdn</a> 就能发现，它的性能并不好，推荐使用 Object.create() 代替，这个下文会讲</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>java 中可以用简单的关键字就实现继承了，但 JavaScript 中并不简单，因为我们要用原型链机制去模拟继承。</p>
<p>在 JavaScript 的历史长河中，模拟继承的实现也有很多种方式，下面我们分别看下。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>通过上面的原型指向（[[Prototype]] 内部属性赋值）已经有些许的继承味道了，所以可以得出如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;dog&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; eat&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.eat();</span><br><span class="line">dog.sayName();</span><br></pre></td></tr></table></figure>

<p><strong>把子类构造函数的 prototype 赋值为父类的实例。</strong>你能说出 sayName 的调用是如何执行的吗？</p>
<p>优点：实例 与 原型的关系可用 instanceof、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf">isPrototypeOf()</a> 判断（文档中为什么是 Object.prototype.isPrototypeOf() 呢？这个和 Object.defineProperty() 有什么区别呢）</p>
<p>原型链的问题：</p>
<ol>
<li><p>子类型在实例化时不能给父类型的构造函数传参</p>
</li>
<li><p>父类的实例中包含引用值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">const</span> dog2 = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">dog1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1.colors);</span><br><span class="line"><span class="built_in">console</span>.log(dog2.colors);</span><br></pre></td></tr></table></figure>

<p>因为多个 Dog 的实例的原型都是同一个，也就是 Dog.prototype 即 一个Animal的实例，那么如果Animal的实例有引用类型，就会导致多个 Dog 的实例的原型使用同一个引用类型</p>
</li>
</ol>
<h3 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h3><p>相比于原型链，此方法多了一步：在子类构造函数中调用父类构造函数（把父类构造函数那过来给子类的构造函数中使用了，所以叫 盗用构造函数 嘛）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>); <span class="comment">// 重点：新增代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重点：删除了 Dog.prototype 的赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">const</span> dog2 = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">dog1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1.colors);</span><br><span class="line"><span class="built_in">console</span>.log(dog2.colors);</span><br></pre></td></tr></table></figure>

<p>相比于原型链：</p>
<ol>
<li>可以传递参数</li>
<li>引用类型在每个子类的实例上都有，解决了使用多个子类的实例使用共同的引用类型问题</li>
</ol>
<p>盗用构造函数的问题：</p>
<ol>
<li>dog1 instanceof Animal 为 false</li>
<li>定义函数只能在子类的构造函数中，又回到了上文的函数不能复用的问题</li>
</ol>
<p>其实这个更像是借助构造函数实现了对象的组合</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>原型链 + 盗用构造函数 的组合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>, name); <span class="comment">// 重点：用于继承 Animal 构造函数中的属性（方法最好不要写在构造函数中，否则会难以复用）</span></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal(); <span class="comment">// 重点：这里用于继承 Animal.prototype 中的方法</span></span><br><span class="line">Dog.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; eat&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;foo&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">dog1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line">dog1.eat();</span><br><span class="line">dog1.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(dog1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">&#x27;bar&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog2);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>方法一般定义在 构造函数.prototype 上，这里是在每个实例指向的原型，可以在多个实例中复用</li>
<li>属性一般定义在构造函数的 this 赋值上，这里会在每个实例中都存在</li>
<li>静态属性和静态方法其实就是构造函数的属性而已</li>
</ol>
<p>组合继承弥补了原型链和盗用构造函数的不足，<strong>是 JavaScript 中使用最多的继承模式</strong>。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法 识别对象的能力</p>
<p>组合继承虽然很强大，但仍存在问题的：</p>
<ol>
<li>子类实例的原型中冗余存储了一份数据，也就是由于父类构造函数被调用 2 次所造成的</li>
</ol>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-11/05_09:16_Wg751S.png" alt="image-2022110591651230 AM"></p>
<p>如果想要完美的解决这个问题，就得先了解下其他内容</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>这和上面的 3 种继承方式关系不大，学习这个时，可以先忘掉刚学内容</p>
<p>Douglas Crockford 曾写过一篇文章，介绍了一种不涉及严格意义上构造函数的继承方法。</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-11/05_09:17_mn2XAH.png" alt="image-2022110591711716 AM"></p>
<p>JSON、JSLint 创造者，JavaScript语言精粹 作者</p>
<p>他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。最终给出了一个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;Shelby&#x27;</span>, <span class="string">&#x27;Court&#x27;</span>, <span class="string">&#x27;Van&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&#x27;Greg&#x27;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&#x27;Rob&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&#x27;Linda&#x27;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&#x27;Barbie&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson)</span><br><span class="line"><span class="built_in">console</span>.log(yetAnotherPerson)</span><br></pre></td></tr></table></figure>

<p>原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改。</p>
<p>本质上，object()是对传入的对象执行了一次浅复制 （和扩展运算符类型，只不过他是在原型上，以及你可以在新对象中覆盖原型）</p>
<p>我的理解：创建一个对象，并把原型设置为参数，之后返回对象</p>
<p>Object.create() 就是这玩意，只不过多了个参数</p>
<p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>原型式继承 + 对象属性赋值 + 工厂模式（就是在原型式继承的基础上，用工厂函数包起来，之后可以自定义一些属性）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = object(original);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;Shelby&#x27;</span>, <span class="string">&#x27;Court&#x27;</span>, <span class="string">&#x27;Van&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();</span><br></pre></td></tr></table></figure>

<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。</p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>寄生式继承 + 组合继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = object(superType.prototype);</span><br><span class="line">  prototype.constructor = subType;</span><br><span class="line">  subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里没有 new 了，所以不会再冗余生成一遍属性，而且还能把方法继承下来</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> SubType(<span class="string">&#x27;foo&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>寄生式组合继承可以算是引用类型继承的最佳模式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我们整天在写 JavaScript 代码，但有些很基础的东西却了解的不够深入，遇到些疑难杂症就束手无策了，所以应该练好基本功。</p>
<p>虽然现在都用 class 和 extend 关键字来实现类与继承了，但其底层原理就是用本文的内容实现的，你可以把它们认为是高级的语法糖。对于他们的使用也有启发意义，比如类里可以定义 getter 和 setter、私有属性为什么那么难实现？</p>
<p>还可以自己用代码找出 String 的 api </p>
<p>对于看文档时，api之间的联系也能更清晰，如 File api 他是继承自 Blob 的，这样查阅 api 更有联系，容易记住</p>
<p>学习了这些内容，在回看这段简单的代码是如何执行的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Mozilla&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">1</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/11/05/JavaScript/JavaScript%20%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%A7%E6%89%BF/" data-id="clf0n06ru0014b2of8dvj0dmm" data-title="JavaScript 的对象与继承" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/可选链操作符" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/11/04/JavaScript/%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="article-date">
  <time class="dt-published" datetime="2022-11-04T22:52:49.000Z" itemprop="datePublished">2022-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/11/04/JavaScript/%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6/">可选链运算符</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>可选链运算符（optional chaining operator）即<code>?.</code>运算符。它可以获取对象的属性或调用方法，如果对象是 undefined 或 null，那么会返回 undefined，而不是直接抛错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> adventurer = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">    <span class="attr">cat</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Dinah&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dogName = adventurer.dog?.name;</span><br><span class="line"><span class="built_in">console</span>.log(dogName);</span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adventurer.someNonExistentMethod?.());</span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.val?.prop</span><br><span class="line">obj.val?.[expr]</span><br><span class="line">obj.func?.(args)</span><br></pre></td></tr></table></figure>

<p>注意这里方法和属性变量的使用。</p>
<p>简单来说：<code>?.</code>运算符很像<code>.</code>运算符，除了它不会报错。如果 <code>?.</code>运算符前面的内容是 undefined 或 null，那么后面接的属性的获取或方法的调用，不会抛错，并且返回 undefined。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>在之前，如果你想要探索对象是否存在属性，要这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedProp = obj.first &amp;&amp; obj.first.second;</span><br></pre></td></tr></table></figure>

<p>这在 JS 中是惯用模式，但他有一下问题：</p>
<ol>
<li>当嵌套层级很深时，代码冗余，过于啰嗦。</li>
<li>当<code>obj.first</code>的值是 Falsy 的时候，比如<code>0</code>，那么<code>nestedProp</code>的值就会变成<code>0</code>，而不是期望的 <code>obj.first.second</code> 的值或者<code>undefined</code></li>
</ol>
<p>但如果你使用<code>?.</code>运算符，那就很奈斯：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedProp = obj.first?.second;</span><br></pre></td></tr></table></figure>

<p>这样就解决了以上两个问题。</p>
<blockquote>
<p>当然，你可能见过另一种解决方案，就是 <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.17.15#get">lodash 的 get 方法</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.get(obj, <span class="string">&#x27;first.second&#x27;</span>, <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>

<p>说实话，我更喜欢这个，因为它更强大，可惜的是，这并不是语言标准 😭</p>
</blockquote>
<p>更准确来说，<code>?.</code>运算符其实是下面的语法糖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = obj.first;</span><br><span class="line"><span class="keyword">const</span> nestedProp =</span><br><span class="line">    temp === <span class="literal">null</span> || temp === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : temp.second;</span><br></pre></td></tr></table></figure>

<p><code>?.</code>运算符不可以用在没有声明的根对象上（如果用了会报错），但是可以用在已经声明的根对象的没有定义的属性上。</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-11/04_20:00_jOkYeL.png" alt="image-2022110480049953 PM"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b?.a;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = &#123;&#125;;</span><br><span class="line">c.d?.e;</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>b 是未定义的对象，会报错，c 是定义了的，不会报错。</p>
<h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = someInterface.customMethod?.();</span><br></pre></td></tr></table></figure>

<p>常见于一些 api 可能未实现的情况。这里的调用会返回 undefined，而不是报错。</p>
<p>注意：如果<code>customMethod</code>是已经存在的属性，但不是方法，那即使这样写了也是会报错的。</p>
<h3 id="用于表达式"><a href="#用于表达式" class="headerlink" title="用于表达式"></a>用于表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedProp = obj?.[<span class="string">&#x27;prop&#x27;</span> + <span class="string">&#x27;Name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>常用于数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMagicIndex</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr?.[<span class="number">42</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMagicIndex([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// undefined</span></span><br><span class="line">printMagicIndex(); <span class="comment">// undefined; if not using ?., this would throw</span></span><br></pre></td></tr></table></figure>

<p><code>?.</code>运算符是不能在赋值左侧使用的，但<code>.</code>运算符是可以的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">object?.property = <span class="number">1</span>; <span class="comment">// SyntaxError: Invalid left-hand side in assignmen</span></span><br></pre></td></tr></table></figure>

<h3 id="短路操作"><a href="#短路操作" class="headerlink" title="短路操作"></a>短路操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> potentiallyNullObj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> prop = potentiallyNullObj?.[x++];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 0 as x was not incremented</span></span><br></pre></td></tr></table></figure>

<p>如果<code>?.</code>前面的内容是 nullish，那么就不会执行后面的表达式，后续的属性访问也同样不会执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> potentiallyNullObj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> prop = potentiallyNullObj?.a.b;</span><br><span class="line"><span class="comment">// This does not throw, because evaluation has already stopped at</span></span><br><span class="line"><span class="comment">// the first optional chain</span></span><br></pre></td></tr></table></figure>

<p>其实就是下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> potentiallyNullObj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> prop =</span><br><span class="line">    potentiallyNullObj === <span class="literal">null</span> || potentiallyNullObj === <span class="literal">undefined</span></span><br><span class="line">        ? <span class="literal">undefined</span></span><br><span class="line">        : potentiallyNullObj.a.b;</span><br></pre></td></tr></table></figure>

<p>但你如果用括号提升优先级，那么是有可能报错的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> potentiallyNullObj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> prop = (potentiallyNullObj?.a).b;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="用于可选的回调函数"><a href="#用于可选的回调函数" class="headerlink" title="用于可选的回调函数"></a>用于可选的回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code written without optional chaining</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">onContent, onError</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with the data</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// Testing if onError really exists</span></span><br><span class="line">        <span class="keyword">if</span> (onError) &#123;</span><br><span class="line">            onError(err.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里 onError 可能没有传值，所以要判断下，但如果用可选链，就比较简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using optional chaining with function calls</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">onContent, onError</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with the data</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        onError?.(err.message); <span class="comment">// No exception if onError is undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连续可选链"><a href="#连续可选链" class="headerlink" title="连续可选链"></a>连续可选链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> customerCity = customer.details?.address?.city;</span><br></pre></td></tr></table></figure>

<h3 id="与空值合并运算符结合使用"><a href="#与空值合并运算符结合使用" class="headerlink" title="与空值合并运算符结合使用"></a>与空值合并运算符结合使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCustomerCity</span>(<span class="params">customer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> customerCity = customer?.city ?? <span class="string">&#x27;Unknown city&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(customerCity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printCustomerCity(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Nathan&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;Paris&#x27;</span>,</span><br><span class="line">&#125;); <span class="comment">// &quot;Paris&quot;</span></span><br><span class="line">printCustomerCity(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Carl&#x27;</span>,</span><br><span class="line">    <span class="attr">details</span>: &#123; <span class="attr">age</span>: <span class="number">82</span> &#125;,</span><br><span class="line">&#125;); <span class="comment">// &quot;Unknown city&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符"></a>空值合并运算符</h2><p>空值合并运算符 即<code>??</code>，它的作用是如果<code>??</code>左边是 nullish，那么返回右边，否则返回左边，它和<code>||</code>运算符很相似，<code>||</code>运算符左边是 Falsy 的话返回右边，否则返回左边。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional chaining (?.)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish">nullish</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">Falsy</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing">Nullish coalescing operator (??)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/11/04/JavaScript/%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6/" data-id="clf0n06s9001qb2of6azihv2e" data-title="可选链运算符" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/JavaScript 对象解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/08/03/JavaScript/JavaScript%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2022-08-03T22:57:58.000Z" itemprop="datePublished">2022-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/08/03/JavaScript/JavaScript%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E8%AF%BB/">JavaScript 对象解读</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对象一直都是 JavaScript 里重要的概念，如函数、正则等全部都是对象，本文将带大家深入的了解对象相关知识。</p>
<h2 id="数据属性、访问器属性"><a href="#数据属性、访问器属性" class="headerlink" title="数据属性、访问器属性"></a>数据属性、访问器属性</h2><p>对象是 JavaScript 中的一种数据类型，对象由属性和属性值组成（通常也叫 key 和 value），属性的数据类型只能是字符串或 Symbol，每个属性都有 4 个描述符，根据描述符的不同，属性又分为两种类型，数据属性和访问器属性。</p>
<p>数据属性的属性描述符：</p>
<ol>
<li>[[Configurable]]：属性是否可以通过 delete 删除，是否可以修改它的描述符，以及是否可以在数据属性与访问器属性之间切换。</li>
<li>[[Enumerable]]：是否 for in 循环、Object.keys() 可访问。</li>
<li>[[Value]]：属性值</li>
<li>[[Writable]]：是否可以修改 [[Value]]</li>
</ol>
<p>访问器属性的属性描述符：</p>
<ol>
<li>[[Configurable]]：同上</li>
<li>[[Enumerable]]：同上</li>
<li>[[Get]]：函数，在读取属性时调用</li>
<li>[[Set]]：函数，在写入属性时调用</li>
</ol>
<blockquote>
<p>疑问：[[Get]] 这种双中括号代表什么？</p>
<p>答：[[Get]] 这种双中括号的表示一般在<a target="_blank" rel="noopener" href="https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-topropertydescriptor">规范文档</a>中，代表是引擎的内部属性，除非语法上支持，否则 JS 代码是不能访问引擎的内部属性的。类似的还有<code>Date.prototype[@@toPrimitive]</code> 这种 @@ 表示的，代表 Symbol.toPrimitive。</p>
</blockquote>
<p>如果你用过 vue 2，肯定 console.log 过 vue 的响应式变量，它就是通过访问器属性实现的。访问器属性的属性值在控制台出现后有 3 个点，点击 3 个点会调用[[Get]]函数。</p>
<p>下面我们实现一个访问器属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;call&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-07/31_16:15_GxBhSe.png" alt="image-2022073141522184 PM"></p>
<p>点击 3 个点之后会调用 get 函数，并获得返回值</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-07/31_16:16_noD8TB.png" alt="image-2022073141636960 PM"></p>
<p>从下面输出的 call 可以看出调用了 get 函数</p>
<p><code>Object.defineProperty</code> 可以给对象的属性配置描述符，它同时包含了新建和修改的功能，如果对象没有此属性就会新建，如果对象以及有了属性，那么再定义就会修改。</p>
<p>其实我们平常用字面量创建的属性都是数据属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种表示，是一样的</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj2, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用 getOwnPropertyDescriptor 获取到属性的描述符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="调用的-api，也只是属性"><a href="#调用的-api，也只是属性" class="headerlink" title="调用的 api，也只是属性"></a>调用的 api，也只是属性</h2><p>在编写代码的过程中，免不了要调用数组、字符串等等的 api，他们不是什么神奇的东西，也只是普通属性而已。以常用的<code>Array.prototype.map()</code>api 为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(arr, <span class="string">&#x27;map&#x27;</span>));</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>咦，你在骗我呀，我获取到的怎么是 undefined 呢？别急，因为 getOwnPropertyDescriptor 只能获取到当前对象的属性，但 map 属性是在当前对象的原型上的（因为是 Array.prototype 上的属性），所以应该去原型上获取：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.getPrototypeOf(arr), <span class="string">&#x27;map&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;writable: true, enumerable: false, configurable: true, value: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到 map api 是数据属性，并且不可枚举，但是可配置，我们可以试一下把它配置成可枚举的，这样 for in 或 Object.keys 就能访问到了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.getPrototypeOf(arr), <span class="string">&#x27;map&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map</span></span><br></pre></td></tr></table></figure>

<p>但 length 属性是不可配置的，即 configurable 为 false。</p>
<p>所以我们可以通过 JS 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">内置对象</a>拿到所有规定的全局变量，之后再寻找内置对象的原型并输出他的属性，就可以通过代码获取到 JS 所有的 api。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用字面量直接定义属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ming&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.introduce();</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>当你要定义多个对象的时候，直接复制多个还是有些麻烦，所以可以写一个工厂函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age,</span><br><span class="line">        <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = createPerson(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = createPerson(<span class="string">&#x27;foo&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">p2.introduce();</span><br></pre></td></tr></table></figure>

<p>此模式的问题是无法使用 instanceof 等判断对象的类型</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数就是一个普通函数，只不过一般约定构造函数的首字母是大写的，以及它只会和 new 搭配使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.introduce = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">p1.introduce();</span><br></pre></td></tr></table></figure>

<p>它模仿了 Java 的写法，这里和 createPerson 的区别是：</p>
<ol>
<li>没有 return。</li>
<li>属性和方法直接赋值给了 this。</li>
<li>没有显式地创建对象。</li>
</ol>
<p>如果想要继续深入继承部分的内容，那么这里就要深入理解下：</p>
<ol>
<li><p>这应该是个很明显的约定，构造函数是不应该 return 的，如果 return 了那不就回到了工厂模式嘛</p>
</li>
<li><p>this 是很微妙的存在，如果没有 this 会怎样？</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ming&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有 this，这里只能使用 person</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + person.name);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里不能复用，只能是一个新的函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + animal.name);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>没有显式地创建对象，那对象哪里来的？是 new “惹的祸”，new 干了什么？想要知道这个，你就得先了解原型链</p>
</li>
</ol>
<h4 id="原型链机制"><a href="#原型链机制" class="headerlink" title="原型链机制"></a><strong>原型链机制</strong></h4><p>如下代码输出什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.x);</span><br></pre></td></tr></table></figure>

<p>输出是 1，没有在对象 obj 上定义 x 属性，但为什么能获取到呢？因为<strong>对象在获取属性时，如果当前的对象没有，那么就会向当前对象的原型对象去寻找，如果原型对象还没有就继续向上寻找，直到没有原型对象为止。</strong>这就是原型链机制，根据原型为链条寻找属性的机制。代码中的 <code>__proto__</code> 属性就是这里说的原型。</p>
<h4 id="proto-vs-Prototype-vs-prototype"><a href="#proto-vs-Prototype-vs-prototype" class="headerlink" title="__proto__ vs [[Prototype]] vs prototype"></a><code>__proto__</code> vs <code>[[Prototype]]</code> vs <code>prototype</code></h4><p>你肯定见过这三兄弟，他们都和原型有关，他们的区别一定要搞清楚：</p>
<ol>
<li> <code>__proto__</code> 属性：每个对象都有此属性，代表原型，是非标准的历史遗留属性，虽然可用，但现在并不推荐使用。</li>
<li> <code>[[Prototype]]</code> 内部属性：每个对象都有此属性，代表原型，是 ES 规范中的描述，<strong>和 <code>__proto__</code> 属性完全一样</strong>，更推荐现代语法使用，但内部属性是不能直接在 JavaScript 语言层面访问的，还好语言标准提供了 Object.getPrototypeOf() 和 Object.setPrototypeOf() 获取和设置原型。</li>
<li> <code>prototype</code> 属性：每个函数都有 <code>prototype</code>属性，他只有在此函数作为构造函数时才有意义。不要忘记：函数也是对象，所以可以在对象上添加任意属性， <code>prototype</code> 属性就只是函数上的一个普通属性而已，只不过此属性在继承时有特殊的约定含义。</li>
</ol>
<p>可通过控制台看到如下代码原型链图示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(foo, bar);</span><br><span class="line"><span class="built_in">console</span>.log(bar, foo);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-08/03_16:40_t7FwLF.png" alt="image-2022080344043135 PM"></p>
<p>把 foo 的原型指向了 bar，控制台中发现 foo 的原型多了一层。（注意：这里使用了 setPrototypeOf，仅用于演示，如果你看过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">setPrototypeOf 的 mdn</a> 就能发现，它的性能并不好，推荐使用 Object.create() 代替）</p>
<h4 id="实现-new"><a href="#实现-new" class="headerlink" title="实现 new"></a>实现 new</h4><p>知道了原型链机制，那么现在就可以分析 new 干了什么</p>
<ol>
<li>创建一个新对象 foo</li>
<li>将新对象 foo 的 [[Prototype]] 内部属性赋值为构造函数的 prototype 属性</li>
<li>使用新对象 foo 的上下文执行构造函数（即构造函数中的 this 会指向新对象，并为这个新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回构造函数返回的对象；否则，返回新对象 foo</li>
</ol>
<p>构造函数的 prototype 属性就特殊在这里，新对象 foo 的原型会指向构造函数的 prototype 属性。prototype 属性值是一个对象，对象中有一个 constructor 属性，属性值是构造函数，这个 constructor 属性到底有什么用呢？🧐</p>
<p>我在看了半天 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor#browser_compatibility">mdn</a> 后得出结论：它没什么用 😅。它有一个比较常见的用法是用于判断对象的类型，但它很容易被赋值或删除，相比于 instanceof 和 Symbol.toStringTag 来说并不可靠，其实这两个也并非绝对可靠。（这里说的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag">Symbol.toStringTag</a> 指 Object.prototype.toString()）</p>
<p>知道了原理，我们实现一个自己的 new：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fun, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="built_in">Object</span>.create(fun.prototype);</span><br><span class="line">    <span class="keyword">const</span> res = fun.apply(foo, args);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.introduce = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">p1.introduce();</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fun, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="built_in">Object</span>.create(fun.prototype);</span><br><span class="line">    <span class="keyword">const</span> res = fun.apply(foo, args);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = myNew(Person, <span class="string">&#x27;ming2&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">p2.introduce();</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br></pre></td></tr></table></figure>

<p>new 的实现很重要，一定要理解好。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>构造函数模式创建对象的问题是函数难以复用，使用原型模式创建对象就可以解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.introduce = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;ming3&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.introduce === p3.introduce);</span><br></pre></td></tr></table></figure>

<p>这样的代码你是不是在哪里见过？（Vue 2 的插件就是这样加上的）</p>
<p>当然我们写的对象字面量、数组字面量实例都是用这种方法创建出来的，不信你可以试试如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.test = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125; 字面量就相当于 new Object()</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.test);</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.testFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;nb&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>].testFn();</span><br><span class="line"><span class="comment">// nb</span></span><br><span class="line"><span class="comment">// [1, 5]</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/08/03/JavaScript/JavaScript%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E8%AF%BB/" data-id="clf0n06rt0012b2of9t7n1uno" data-title="JavaScript 对象解读" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/js-promise" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/07/17/JavaScript/js-promise/" class="article-date">
  <time class="dt-published" datetime="2022-07-17T22:52:20.000Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/07/17/JavaScript/js-promise/">JavaScript 异步与 Promise</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="异步是什么？"><a href="#异步是什么？" class="headerlink" title="异步是什么？"></a>异步是什么？</h2><p>异步是相对于同步而言的，那同步是什么呢？简单说就是干完a事情，之后再干b事情，这挺正常的，人的思维都是这样做事的，那为什么还需要异步呢？举个现实中的例子，比如你已经下单定了外卖，你会什么也不干，一直等到外卖到了之后再做事情吗？显然不会的，你会在外卖到了之前做一些与吃外卖无关的事情，比如看书、刷剧啥的，之后外卖到了，再去吃外卖。</p>
<h2 id="异步解决什么问题？"><a href="#异步解决什么问题？" class="headerlink" title="异步解决什么问题？"></a>异步解决什么问题？</h2><p>更快的完成更多的任务</p>
<p>多线程也能更快的完成任务，但这种方式要比异步更复杂，因为会引发多个线程同时更改数据的问题，就需要加锁来解决</p>
<h2 id="JS中的异步"><a href="#JS中的异步" class="headerlink" title="JS中的异步"></a>JS中的异步</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>那如何实现异步呢？JS中首先使用了回调函数的方式，此方式可以理解为我在下单外卖后，定了一个todo列表（如其中有：取外卖、吃饭、扔垃圾等），之后我就去干其他的事情了，但我的耳朵会一直监听手机铃声，如果铃声响了，并且我也是空闲的状态下，就会去执行todo列表（也就是回调函数），但我如果有其他事情（比如在上厕所），那么就会做完其他事情之后再去执行todo列表。</p>
<p>回到代码，我们知道回调函数会引起回调地狱的问题，所以在写法、可读与维护上都不太好</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>增加了错误处理，内置实现了 Promise.all race 等操作，对于串行请求操作更方便了，回调需要更深层的缩进来实现串行请求，而Promise是在同一层级的链式调用，在下面写代码就行了，而不需要在里面。</p>
<p>Promise的问题是太多模板代码了，写上去一堆then。</p>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>利用了协程的机制，使代码可以执行到一半时，把控制权交给其他函数，之后还可以再拿回来。并且使用回调函数或Promise可以交还执行权，实现自动执行。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async函数是Generator的语法糖，它内置的执行器，并且有更好的语义。</p>
<h2 id="实现自己的-Promise"><a href="#实现自己的-Promise" class="headerlink" title="实现自己的 Promise"></a>实现自己的 Promise</h2><h3 id="分析基本"><a href="#分析基本" class="headerlink" title="分析基本"></a>分析基本</h3><p>可以先写一个简单的实现，同步版本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyPromise 实现（同步版本）</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    executor(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  status = PENDING;</span><br><span class="line"></span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">      <span class="built_in">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  then = <span class="function">(<span class="params">onFulfilled, onRejected</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">  reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reject&#x27;</span>, error);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>之后再实现一个异步版本：（增加onFulfilledCallback等回调函数的存储，在then的时候如果状态是pending，那么就存下来，之后在resolve的时候再去执行）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyPromise 实现（异步版本，可注册多个 then）</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    executor(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  status = PENDING;</span><br><span class="line"></span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  onFulfilledCallbacks = [];</span><br><span class="line">  onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">      <span class="built_in">this</span>.reason = reason;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  then = <span class="function">(<span class="params">onFulfilled, onRejected</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最终版本：then方法的链式调用、增加错误捕获：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyPromise 实现（then链式调用）</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    executor(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  status = PENDING;</span><br><span class="line"></span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  onFulfilledCallbacks = [];</span><br><span class="line">  onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks.shift()(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">      <span class="built_in">this</span>.reason = reason;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.shift()(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  then = <span class="function">(<span class="params">onFulfilled, onRejected</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">        resolvePromise(x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    x.then(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">other</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;other&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> other();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在then中返回自身会产生错误，在代码中不要这样操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p1 = promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="keyword">return</span> p1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-async.html">https://www.runoob.com/js/js-async.html</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/generator-async">https://es6.ruanyifeng.com/#docs/generator-async</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6945319439772434469">https://juejin.cn/post/6945319439772434469</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/07/17/JavaScript/js-promise/" data-id="clf0n06rx001ab2of20d8hnvy" data-title="JavaScript 异步与 Promise" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/js-regexp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/07/17/JavaScript/js-regexp/" class="article-date">
  <time class="dt-published" datetime="2022-07-17T22:30:37.000Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/07/17/JavaScript/js-regexp/">JavaScript 正则理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>正则表达式可以帮我们匹配字符串，大多数语言都有自己对于正则表达式的实现，这里我们看下JavaScript的实现。</p>
<h2 id="正则的标准"><a href="#正则的标准" class="headerlink" title="正则的标准"></a>正则的标准</h2><p>它由正则表达式主体和修饰符组成</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">执行多行匹配。</td>
</tr>
</tbody></table>
<h3 id="正则表达式主体"><a href="#正则表达式主体" class="headerlink" title="正则表达式主体"></a>正则表达式主体</h3><p>也叫「模式」pattern</p>
<p>方括号或圆括号，匹配你想要的字符范围</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[abc]</td>
<td align="left">查找方括号之间的任何字符。</td>
</tr>
<tr>
<td align="left">[^abc]</td>
<td align="left">查找任何不在方括号之间的字符。</td>
</tr>
<tr>
<td align="left">[0-9]</td>
<td align="left">查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">查找任何从小写 a 到小写 z 的字符。</td>
</tr>
<tr>
<td align="left">[A-z]</td>
<td align="left">查找任何从大写 A 到小写 z 的字符。（根据ASCII码顺序的）</td>
</tr>
<tr>
<td align="left">(red|blue|green)</td>
<td align="left">查找任何指定的选项。（非单个字符，可以是连续的）</td>
</tr>
</tbody></table>
<p>有一些字符集是很常用的，如<code>[0-9]</code>代表数字，每次都这样写就比较麻烦，所以正则提供了元字符，如下（小写代表匹配，大写代表排除）：</p>
<table>
<thead>
<tr>
<th align="left">元字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">查找单个字符，除了换行和行结束符。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">word 查找数字、大小写字母、下划线。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">非 word</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">digit 查找数字</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">非 digit</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">whitespace 查找空白字符。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">非 whitespace</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">Word boundary 匹配单词边界。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非 Word boundary</td>
</tr>
<tr>
<td align="left">\0</td>
<td align="left">查找 NULL 字符。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">查找换行符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">查找换页符。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">查找回车符。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">查找制表符。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">查找垂直制表符。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-octal.html">\xxx</a></td>
<td align="left">查找以八进制数 xxx 规定的字符。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-hex.html">\xdd</a></td>
<td align="left">查找以十六进制数 dd 规定的字符。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-unicode-hex.html">\uxxxx</a></td>
<td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody></table>
<p>以上元字符有些是常用字符的集合，有些是不好表示的字符的替代展示</p>
<p>上文讲的，都是对于单个字符，如果你想要这个模式出现10次，怎么办呢，难道要写10遍吗？不用那么麻烦的，只需要使用到量词即可</p>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><table>
<thead>
<tr>
<th align="left">量词</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-onemore.html">n+</a></td>
<td align="left">匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-zeromore.html">n*</a></td>
<td align="left">匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-zeroone.html">n?</a></td>
<td align="left">匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 “angel” 中的 “el”，”angle” 中的 “le”。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nx.html">n{X}</a></td>
<td align="left">匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nxcomma.html">n{X,}</a></td>
<td align="left">X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nxy.html">n{X,Y}</a></td>
<td align="left">X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a{1,3}/ 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-ndollar.html">n$</a></td>
<td align="left">匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-ncaret.html">^n</a></td>
<td align="left">匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nfollow.html">?=n</a></td>
<td align="left">匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nfollow-not.html">?!n</a></td>
<td align="left">匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
</tbody></table>
<p><code>+</code>是<code>&#123;1,&#125;</code>，<code>*</code>是<code>&#123;0,&#125;</code>，<code>?</code>是<code>&#123;0,1&#125;</code>，这些也只是个数范围的简写罢了</p>
<p><code>^n</code>是匹配以n开头，<code>n$</code>是匹配以n结尾</p>
<p><code>a(?=n)</code>是匹配后面为n的a字符串，<code>a(?!n)</code>反之，这个叫做先行断言（lookahead assertion）</p>
<p><code>(?&lt;=n)a</code>是匹配前面为n的a字符串，<code>(?&lt;!n)a</code>反之，这个叫做后行断言（lookbehind assertion），这种方式并不是所有浏览器都支持</p>
<p><code>^n</code>可以用后行断言表示，<code>n$</code>可以用先行断言表示，这两个也算是另一种形式的简写啦</p>
<p><strong>贪婪匹配与非贪婪匹配</strong></p>
<p><code>+</code>和<code>*</code>都是可以匹配多个的，那么他们默认是贪婪匹配，就是尽可能的多匹配内容，那么你想让他们尽可能的少匹配内容时，只要<code>+</code>和<code>*</code>的后面加上<code>?</code>即可，他们就变成了非贪匹配</p>
<h2 id="JavaScript-中的正则使用"><a href="#JavaScript-中的正则使用" class="headerlink" title="JavaScript 中的正则使用"></a>JavaScript 中的正则使用</h2><h3 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h3><p><strong>test 方法</strong></p>
<p>查看字符串是否符合你的正则</p>
<p><code>/\d/.test(&#39;sdfd1&#39;)</code></p>
<p><strong>toString 方法</strong></p>
<p>查看正则表示的字符串模式</p>
<p><code>new RegExp(&#39;\\d&#39;,&#39;g&#39;).toString()</code></p>
<p><strong>exec 方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex1 = <span class="built_in">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;table football, foosball&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> array1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((array1 = regex1.exec(str1)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Found <span class="subst">$&#123;array1[<span class="number">0</span>]&#125;</span>. Next starts at <span class="subst">$&#123;regex1.lastIndex&#125;</span>.`</span>);</span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 9.&quot;</span></span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 19.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><p><strong>search 方法</strong></p>
<p><code>&#39;df1&#39;.search(/\d/)</code></p>
<p><strong>match 方法</strong></p>
<p><code>&#39;The rain in SPAIN stays mainly 3 in2 the plain1&#39;.match(/\d/g)</code> 结果是 <code>[&#39;3&#39;, &#39;2&#39;, &#39;1&#39;]</code></p>
<p><strong>replace 方法</strong></p>
<p><code>&#39;haha6 nb 345 lihai5&#39;.replace(/\d/g, &#39;zmy&#39;)</code> 结果<code>&#39;hahazmy nb zmyzmyzmy lihaizmy&#39;</code></p>
<p><strong>split 方法</strong></p>
<p><code>&#39;haha6 nb 345 lihai5&#39;.split(/\d/)</code> 结果<code>[&#39;haha&#39;, &#39; nb &#39;, &#39;&#39;, &#39;&#39;, &#39; lihai&#39;, &#39;&#39;]</code>，注意：边界内容会变成空字符串</p>
<p>在线测试工具：<a target="_blank" rel="noopener" href="https://regexr.com/">https://regexr.com/</a></p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-obj-regexp.html">https://www.runoob.com/jsref/jsref-obj-regexp.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/07/17/JavaScript/js-regexp/" data-id="clf0n06ry001cb2of3bpe4e8b" data-title="JavaScript 正则理解" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/symbol" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/07/17/JavaScript/symbol/" class="article-date">
  <time class="dt-published" datetime="2022-07-17T15:32:36.000Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/07/17/JavaScript/symbol/">JavaScript Symbol 解读</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>作为一名高级前端工程师，你一定见过类似这个的东西<code>Symbol.toPrimitive</code>、<code>@@toPrimitive</code>，他其实就是本文要讲的 Symbol，让我们一起了解下吧</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Symbol 是一个内置对象，构造函数（这是一个特殊的构造函数，因为他不能使用 new，只能直接调用）返回 Symbol 原始类型，用于返回一个唯一值（这个唯一值是什么并不重要，重要的是他和所有的其他值都不相等），如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;desc&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>就只有 a 能访问到 <code>Symbol(&#39;desc&#39;)</code>的值，就算你再定义一个相同的值，他们也是不相同的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;desc&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b === a);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以发现 ‘desc’ 根本就没啥实际用处，确实是这样，他在这里只是起到了注释的作用</p>
<p>Symbol 的一大用处就是作为对象的 key（对象的 key 只能是 Symbol 或字符串这两种类型），它可以避免和已有的 key 或新增的 key 冲突。Symbol 上还有一些静态属性，他们被称为众所周知的（well-known）Symbol，用于在一些特殊操作时底层的调用</p>
<p>你如果想定义一个想让其他变量也能获取的 Symbol，也是可以的，要通过 <code>Symbol.for(&quot;key&quot;)</code> 静态方法，他会先在 Symbol 全局注册表上注册一个 key，然后返回，下次你在调用的时候就直接返回已有值了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局注册表中注册 zmy 这个 key</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;zmy&#x27;</span>);</span><br><span class="line"><span class="comment">// 在全局注册表中获取 zmy key 的值</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;zmy&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 还可以有 keyFor 或 description 获取对应的描述</span></span><br><span class="line"><span class="built_in">console</span>.log(a.description, <span class="built_in">Symbol</span>.keyFor(a));</span><br><span class="line"><span class="comment">// zmy zmy</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么-Symbol-不能用-new-创建？"><a href="#为什么-Symbol-不能用-new-创建？" class="headerlink" title="为什么 Symbol 不能用 new 创建？"></a>为什么 Symbol 不能用 new 创建？</h3><p>我们可以用 String 类比举例一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="number">97</span>));</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">97</span>));</span><br><span class="line"><span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>String 构造函数直接调用是为了强制转换的，new String 是为了获得 string 对象的，首先你肯定不想获得 Symbol 对象，你要的是 Symbol 原始类型，所以语言层面上 new Symbol 会报错，这是合理的，因为我们就算有了 Symbol 对象也没有用武之地，但你可以使用<code>Object(Symbol(&#39;f&#39;))</code>强制获取到对象封装的 Symbol</p>
<h2 id="well-known-Symbol"><a href="#well-known-Symbol" class="headerlink" title="well-known Symbol"></a>well-known Symbol</h2><p>把它翻译成众所周知的 Symbol 我还是觉得不太合适，因为一般开发者都不会了解这些 Symbol，所以就用英文原文吧。在 well-known Symbol 之前，都是用字符串来实现调用的，如 <code>JSON.stringify</code> 函数会调用对象的 <code>toJSON()</code>方法，String 强制转换会调用 <code>toString()</code> 方法等。可是随着操作符的逐渐增加，这样使用特殊字符串方法并不好，所以出现了常用 Symbol 来解决这个问题</p>
<p><a target="_blank" rel="noopener" href="https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-well-known-symbols">ES 标准</a> 一共定义了 13 个（标准中也定义了 @@toPrimitive 其实就是 Symbol.toPrimitive，只不过 @@toPrimitive 是在标准中描述的方式，Symbol.toPrimitive 是能在语言中实际用到的功能），下面我们看些常用的</p>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>如果你想要把一个对象类型转为原始类型，那就要使用到 Symbol.toPrimitive 这个 key，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 如果没有定义 Symbol.toPrimitive 这个 key，那么走的是默认行为</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj));</span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给对象定义了 Symbol.toPrimitive key，他的属性值是方法</span></span><br><span class="line"><span class="comment">// 那么在把对象转为原始类型的时候就会使用这个方法</span></span><br><span class="line">obj[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span> (<span class="params">hint</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// hint 的取值有3种：string、number和default</span></span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;mq&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">97</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj));</span><br><span class="line"><span class="comment">// mq</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(obj));</span><br><span class="line"><span class="comment">// 97</span></span><br></pre></td></tr></table></figure>

<p>当然，由于历史原因，你肯定也听说过用 toString 或 valueOf 也能实现以上逻辑，是的，但现代语法还是推荐首先使用 Symbol.toPrimitive 来解决，例子如下：</p>
<p><strong>对象转 string</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="comment">// 1. 首先使用它</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;symbol nb&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 2. 如果没有 @@toPrimitive 那么使用这个</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 不用这个</span></span><br><span class="line">    <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;value of&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(a));</span><br></pre></td></tr></table></figure>

<p><strong>对象转 number</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="comment">// 1. 首先使用它</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">        <span class="comment">// 一定要返回数字类型，否则是 NaN</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">789</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 2. 接着是这个</span></span><br><span class="line">    <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 3. 最后这个</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">567</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(a));</span><br></pre></td></tr></table></figure>

<p>所以这你也应该能理解为什么<code>+moment()</code>的值和 <code>moment().valueOf()</code>的值一样了吧</p>
<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>由于 JavaScript 类型系统的混乱，你一定用过<code>Object.prototype.toString</code>来判断类型，那么 Symbol.toStringTag 就和这个函数有关</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 toString 函数可以判断出数组类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]));</span><br><span class="line"><span class="comment">// [object Array]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么如果你自己定义了一个校验类，想让他在 toString 时能返回特定类型该怎么办呢？</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidatorClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> ValidatorClass()));</span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义他的 Symbol.toStringTag 属性可以改变这个行为</span></span><br><span class="line"><span class="comment">// 此属性是一个字符串</span></span><br><span class="line">ValidatorClass.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Validator&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> ValidatorClass()));</span><br><span class="line"><span class="comment">// [object Validator]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便一提 dom 上有这个属性</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(btn));</span><br><span class="line"><span class="comment">// [object HTMLButtonElement]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到 btn 的原型上是有 Symbol(Symbol.toStringTag) 这个 key 的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(<span class="built_in">Object</span>.getPrototypeOf(btn)));</span><br><span class="line"><span class="comment">// [Symbol(Symbol.toStringTag)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(btn[<span class="built_in">Symbol</span>.toStringTag]);</span><br><span class="line"><span class="comment">// HTMLButtonElement</span></span><br></pre></td></tr></table></figure>

<p>上述代码使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code>Object.getOwnPropertySymbols()</code></a> api，他可以返回一个对象的所有类型为 Symbol 的 key。所有对象初始时都是没有 Symbol 属性的（但是你可以去原型上找 Symbol）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols([]));</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(&#123;&#125;));</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(<span class="built_in">Object</span>.getPrototypeOf([])));</span><br><span class="line"><span class="comment">// [Symbol(Symbol.iterator), Symbol(Symbol.unscopables)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(<span class="built_in">Object</span>.getPrototypeOf(<span class="string">&#x27;zmy&#x27;</span>)));</span><br><span class="line"><span class="comment">// [Symbol(Symbol.iterator)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(<span class="built_in">Object</span>.getPrototypeOf(<span class="function">() =&gt;</span> &#123;&#125;)));</span><br><span class="line"><span class="comment">// [Symbol(Symbol.hasInstance)]</span></span><br></pre></td></tr></table></figure>

<p>当然，有了这个属性之后你可以干些坏事了 🤫</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/1/</span>));</span><br><span class="line"><span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]));</span><br><span class="line"><span class="comment">// [object Array]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;RegExp&#x27;</span>;</span><br><span class="line"><span class="comment">// 这里虽然参数是数组，但由于你改了 toStringTag，所以“变成”了正则类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]));</span><br><span class="line"><span class="comment">// [object RegExp]</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>它可以定义<code>instanceof</code>操作符的行为，是一个函数，有一个参数，是 <code>instanceof</code>操作符前的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 instanceof 操作符后面跟着是构造函数，所以要定义成静态属性</span></span><br><span class="line"><span class="comment">// 也就是要定义在构造函数 MyArray[Symbol.hasInstance] 上</span></span><br><span class="line"><span class="comment">// 而不是原型 MyArray.prototype[Symbol.hasInstance] 上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](instance) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> MyArray);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> MyArray);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>还可以直接调用它来实现 <code>instanceof</code> 操作符的行为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(Animal[<span class="built_in">Symbol</span>.hasInstance](cat));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以你不用认为那些关键字是啥很厉害的东西，就像这里只是一个函数调用而已</p>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>这是一个比较有趣的属性，你如果定义了一个自定义数组类，那么他使用 filter 等方法虽说返回的是新对象，但类型是不变的，如果你想要改变类型，就得使用 Symbol.species</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> MyArray);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> MyArray);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>就像这里，a2 虽然是 filter 出来的新对象，但他仍然是 MyArray 的实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> MyArray);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果把 Symbol.species 属性设置成 Array 的话，那么即使 a1 是 MyArray 的实例，那么他 filter 出来的 a2 也不是 MyArray 的实例，而是 Symbol.species 属性值的实例</p>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>如果想让你的对象能被 for of 遍历，那么就得使用 Symbol.iterator 属性，他是一个 Generator 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串和数组上都有 Symbol.iterator 属性，所以他们能被 for of 遍历</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(<span class="built_in">Object</span>.getPrototypeOf([]));</span><br><span class="line"><span class="comment">// [Symbol(Symbol.iterator), Symbol(Symbol.unscopables)]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(<span class="built_in">Object</span>.getPrototypeOf(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="comment">// [Symbol(Symbol.iterator)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterable = &#123;&#125;;</span><br><span class="line">iterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;zmy&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;learn&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zmy</span></span><br><span class="line"><span class="comment">// learn</span></span><br><span class="line"><span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以使用 spread 运算符</span></span><br><span class="line"><span class="keyword">const</span> list = [...iterable];</span><br><span class="line"><span class="built_in">console</span>.log(list);</span><br><span class="line"><span class="comment">// [&#x27;zmy&#x27;, &#x27;learn&#x27;, &#x27;symbol&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>字符串与数组自带 Symbol.iterator 属性，可以调用生成迭代器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;zmy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> g = s[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());</span><br><span class="line"><span class="built_in">console</span>.log(g.next());</span><br><span class="line"><span class="built_in">console</span>.log(g.next());</span><br><span class="line"><span class="built_in">console</span>.log(g.next());</span><br><span class="line"><span class="comment">// &#123;value: &#x27;z&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: &#x27;m&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: &#x27;y&#x27;, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>这时如果 next 函数返回 Promise 怎么办呢？就需要使用 asyncIterator 和 for await of 了</p>
<p>对于迭代器与生成器推荐看这篇了解一下：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903735534026765">ES9 中的异步迭代器（Async iterator）和异步生成器（Async generator）</a></p>
<h3 id="Symbol-asyncIterator"><a href="#Symbol-asyncIterator" class="headerlink" title="Symbol.asyncIterator"></a>Symbol.asyncIterator</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncIterator = asyncGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> asyncIterator[<span class="built_in">Symbol</span>.asyncIterator]);</span><br><span class="line"><span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> value <span class="keyword">of</span> asyncIterator) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...await...of可以遍历具有Symbol.asyncIterator方法的数据结构</span></span><br><span class="line"><span class="comment">// 并且会等待上一个成员状态改变后再继续执行</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>值是对象，属性名加布尔值，用 with 的时候，如果为 ture，就不能取值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">    <span class="attr">property1</span>: <span class="number">42</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">object1[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">    <span class="attr">property1</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (object1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(property1);</span><br><span class="line">    <span class="comment">// expected output: Error: property1 is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>内部 @@isConcatSpreadable 属性，是布尔值，代表 Array.prototype.concat() 调用时是否拍平数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alpha = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> numeric = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> alphaNumeric = alpha.concat(numeric);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(alphaNumeric);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">numeric[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">alphaNumeric = alpha.concat(numeric);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(alphaNumeric);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, Array [1, 2, 3]]</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-match-等-string-相关-Symbol"><a href="#Symbol-match-等-string-相关-Symbol" class="headerlink" title="Symbol.match 等 string 相关 Symbol"></a>Symbol.match 等 string 相关 Symbol</h3><p>Symbol.match、Symbol.matchAll、Symbol.replace、Symbol.search、Symbol.split，和上文类似，都是在对应 String.prototype 的函数一些特殊处理，有需要再查阅即可</p>
<h2 id="实现私有属性"><a href="#实现私有属性" class="headerlink" title="实现私有属性"></a>实现私有属性</h2><p>Symbol 的另一个作用实现私有属性，可参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SusZu6rdVijZ-6seg9oa0Q">私有属性的 6 种实现方式，你用过几种？</a></p>
<p>参考：</p>
<ol>
<li>mdn symbol：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/07/17/JavaScript/symbol/" data-id="clf0n06s1001jb2ofay10dd91" data-title="JavaScript Symbol 解读" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/defineProperty" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/my-blog/2022/07/10/JavaScript/defineProperty/" class="article-date">
  <time class="dt-published" datetime="2022-07-10T00:00:00.000Z" itemprop="datePublished">2022-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/my-blog/2022/07/10/JavaScript/defineProperty/">defineProperty 详细解读</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对象在 JS 中很重要，如 Number Function 等等都是以对象为基础扩展的，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty</a> 作为定义对象属性的 api，同样不可小觑。本文会详细解读 Object.defineProperty()，带你看透对象的本质。</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-07/11_21:12_gQBBo9.png" alt="image-2022071191209134 PM"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>defineProperty 是 Object 的静态方法，可以在对象上新增一个属性，或者更改对象上已有的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// 严格模式下会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo);</span><br><span class="line"><span class="comment">// 非严格模式下输出 42</span></span><br></pre></td></tr></table></figure>

<p>对象 obj 定义了一个属性 foo，这个属性不能更改，否则会报错（我们现在写的代码几乎都是在严格模式下的，所以本文不考虑非严格模式下的情况）</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<p>obj：你要定义的对象</p>
<p>prop：你要定义的属性，可以是 symbol 类型</p>
<p>descriptor：对于属性的描述</p>
<p>这里最重要的就是 descriptor 了</p>
<h2 id="descriptor-解读"><a href="#descriptor-解读" class="headerlink" title="descriptor 解读"></a>descriptor 解读</h2><p>我们正常的创建、修改、删除和枚举属性是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增属性（定义对象时直接赋值，或者在定义对象后动态赋值）</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line">obj.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举属性（四种方式：Object.keys、for in 操作、Object.assign、扩展操作符）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));</span><br></pre></td></tr></table></figure>

<p>但你可能不希望属性被修改与删除，那就需要 defineProperty 出场了</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-07/11_20:28_pyNAWY.png" alt="image-2022071182854317 PM"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;e&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;zmy&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看属性，虽然控制台输出能看到 e，但 e 是浅色的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// 枚举属性 没有 e</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));</span><br><span class="line"><span class="comment">// 修改属性，报错</span></span><br><span class="line">obj.e = <span class="string">&#x27;mq&#x27;</span>;</span><br><span class="line"><span class="comment">// 删除属性，报错</span></span><br><span class="line"><span class="keyword">delete</span> obj.e</span><br></pre></td></tr></table></figure>

<p>这里，在 obj 上新定义了 e 属性，但它不能修改，不能删除也不能枚举。下面我们看看为什么会这样。</p>
<h3 id="数据属性和访问器属性"><a href="#数据属性和访问器属性" class="headerlink" title="数据属性和访问器属性"></a>数据属性和访问器属性</h3><p>在继续之前你需要知道：根据描述符的种类把属性分为两种，数据（data）属性和访问器（accessor）属性。</p>
<p>数据属性描述符：</p>
<ol>
<li><p>value：属性的值，默认 undefined</p>
</li>
<li><p>writable：属性是否可改变，默认 false</p>
</li>
</ol>
<p>访问器属性：</p>
<ol>
<li><p>get：函数，返回值是属性的值，可用this</p>
</li>
<li><p>set：函数，有一个参数，赋值时被调用，可用this</p>
</li>
</ol>
<p>还有两个描述符，是数据属性和访问器属性都有的：</p>
<ol>
<li>configurable：如果是false，那么：这个属性不能在数据属性和访问器属性之间切换了、属性不能被删除、其他的属性描述符不能被更改了（但当writable描述符是true时，属性的值可以改，writable描述符也可以改为false），默认false</li>
<li>enumerable：是否可枚举（四种方式：Object.keys、for in 操作、Object.assign、扩展操作符），默认false</li>
</ol>
<p>描述符只能是 value 和 writable 组合或 get 和 set 组合，不能混用（会报错）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmy = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute,</span></span><br></pre></td></tr></table></figure>

<p>但属性可以在数据属性和访问器属性之间来回切换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmy = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(zmy.a);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(zmy.a);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(zmy, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;set: undefined, enumerable: false, configurable: true, get: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(zmy.a);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如上 a 属性从数据属性变为访问器属性又变为数据属性，这里注意：我在新增a属性时，configurable设置为true（因为如果是默认的false值，就不能在数据属性和访问器属性之间互相切换了），但第二次修改 a 属性时，并没有特殊设置configurable 的值，它依旧是 true，因为使用了新建时已有的 configurable 的值</p>
<h3 id="定义-descriptor-时的注意点"><a href="#定义-descriptor-时的注意点" class="headerlink" title="定义 descriptor 时的注意点"></a>定义 descriptor 时的注意点</h3><p>定义 descriptor 时最好是给出所有配置，因为这些配置项也可以是继承而来，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.writable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> zmy = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = &#123; <span class="attr">value</span>: <span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">8</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(zmy.a);</span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line">zmy.a = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(zmy.a);</span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br></pre></td></tr></table></figure>

<p>这里由于 defineProperty 的 descriptor 中并没有显示指出 writable，所以它应该是默认值 false 的，故下面的 <code>zmy.a = 7</code> 应该报错，但事实却没有，因为我们在第一行改了<code>Object</code>的原型，导致所有对象都可以找到<code>writable</code>这个属性，所以在defineProperty时就被使用了，这里的 <code>writable</code> 实际为 <code>true</code> 而不是默认值 <code>false</code>（把第一行修改<code>Object</code>原型代码注释，就会正常报错）</p>
<p>当然解决这个问题还有其他方法：</p>
<ol>
<li>如果你的环境下<code>Object.freeze</code>可用，那么就 freeze 住<code>Object</code>实例的原型</li>
<li>descriptor对象使用<code>Object.create(null)</code>获得，因为这样获得的对象不继承于Object</li>
</ol>
<h3 id="configurable-为-false-的注意点"><a href="#configurable-为-false-的注意点" class="headerlink" title="configurable 为 false 的注意点"></a>configurable 为 false 的注意点</h3><p>configurable 为 false 的时候代表不可配置的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmy = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">zmy.q = <span class="number">6</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot assign to read only property &#x27;q&#x27; of object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  Uncaught TypeError: Cannot redefine property: q</span></span><br></pre></td></tr></table></figure>

<p>如上，改值和改描述符都报错，但有个特殊情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmy = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以更改值</span></span><br><span class="line">zmy.q = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(zmy.q);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以正常的把 writable 由 true 变为 false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是把 writable 由 false 变为 true 是会报错的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: q</span></span><br></pre></td></tr></table></figure>

<p>当 configurable 为 false，但是 writable 为 true 时，可以改变属性的 value，可以把 writable 由 true 变为 false，但是把 writable 由 false 变为 true 是会报错的。</p>
<p>（为啥要搞这么麻烦的事呢，我猜一个原因是<code>Object.getOwnPropertyDescriptors([])</code> ，这里 length 属性 configurable就是false，但 writable 为 true，又因为我们是能手动改数组的长度的，所以很符合这种情况）</p>
<p>如果定义的值和原值一样，不会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmy = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有报错，但是如果改成 5 以外的其他值，是都会报错的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="属性值为-undefined"><a href="#属性值为-undefined" class="headerlink" title="属性值为 undefined"></a>属性值为 undefined</h3><p>把属性值变成 undefined 可以删除值 （configurable 等如果是 undefined 就代表是 false）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmy = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    a = val;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">zmy.q = <span class="number">23</span></span><br><span class="line"><span class="comment">// 可以正常赋值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(zmy, <span class="string">&#x27;q&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">zmy.q = <span class="number">45</span></span><br><span class="line"><span class="comment">// 报错，因为没有 set</span></span><br></pre></td></tr></table></figure>

<h3 id="enumerable-举例"><a href="#enumerable-举例" class="headerlink" title="enumerable 举例"></a>enumerable 举例</h3><ol>
<li>Object.assign 和 扩展操作符：只有enumerable为true时可见，包括 symbol 类型</li>
<li>for in 操作  和 Object.key：只有enumerable为true时可见，不包括 symbol 类型</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">3</span></span><br><span class="line">&#125;); <span class="comment">// enumerable 默认为 false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// enumerable 默认为 true</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>), &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>), &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27; and &#x27;d&#x27; (in undefined order)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// [&#x27;a&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line">o.propertyIsEnumerable(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">&#x27;d&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123; ...o &#125;</span><br><span class="line"><span class="comment">// 或者使用 assign，和 扩展操作符一样的</span></span><br><span class="line"><span class="comment">// const p = &#123;&#125;</span></span><br><span class="line"><span class="comment">// Object.assign(p, o)</span></span><br><span class="line">p.a <span class="comment">// 1</span></span><br><span class="line">p.b <span class="comment">// undefined</span></span><br><span class="line">p.c <span class="comment">// undefined</span></span><br><span class="line">p.d <span class="comment">// 4</span></span><br><span class="line">p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)] <span class="comment">// 5</span></span><br><span class="line">p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲解了defineProperty的定义与语法，并对descriptor的配置进行了代码实践。</p>
<p>我认为 defineProperty 是对象中非常重要的 api，你懂了这个再看其他的api仿佛打通了任督二脉，也就不会那么难了</p>
<p><img src="https://raw.githubusercontent.com/acmu/pictures/master/uPic/2022-07/11_20:31_8IXXKP.png" alt="image-2022071183144923 PM"></p>
<p>如：</p>
<ol>
<li><code>Object.defineProperties()</code>就是同时定义多个属性</li>
<li><code>Object.getOwnPropertyDescriptor()</code>就是获取到对象属性的描述符<code>Object.getOwnPropertyDescriptors()</code>也同理啦</li>
<li><code>Object.getOwnPropertyNames()</code>就是获取到所有的属性，包括<code>enumerable</code>为false的属性也能获取到，但不能获取到symbol类型的属性，那我想要获取到所有symbol类型的属性（包括<code>enumerable</code>为false的）该怎么办呢？用<code>Object.getOwnPropertySymbols()</code>即可</li>
<li><code>Object.prototype.propertyIsEnumerable()</code>就不用我说了吧</li>
</ol>
<p>还有很多，剩下的你可以自己去探索一下啦</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://acmu.github.io/2022/07/10/JavaScript/defineProperty/" data-id="clf0n06rw0018b2offd0abhtv" data-title="defineProperty 详细解读" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/my-blog/page/2/">2</a><a class="page-number" href="/my-blog/page/3/">3</a><a class="extend next" rel="next" href="/my-blog/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/my-blog/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/my-blog/tags/TS/" rel="tag">TS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/my-blog/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/my-blog/tags/%E5%91%A8%E5%88%8A/" rel="tag">周刊</a></li><li class="tag-list-item"><a class="tag-list-link" href="/my-blog/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/my-blog/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/" rel="tag">效率工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/my-blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/my-blog/tags/JavaScript/" style="font-size: 16.67px;">JavaScript</a> <a href="/my-blog/tags/TS/" style="font-size: 10px;">TS</a> <a href="/my-blog/tags/%E5%88%B7%E9%A2%98/" style="font-size: 10px;">刷题</a> <a href="/my-blog/tags/%E5%91%A8%E5%88%8A/" style="font-size: 20px;">周刊</a> <a href="/my-blog/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 10px;">工程化</a> <a href="/my-blog/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/" style="font-size: 13.33px;">效率工具</a> <a href="/my-blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.33px;">浏览器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2020/08/">八月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/my-blog/2022/11/16/JavaScript/kind-of%E6%BA%90%E7%A0%81/">周下载量超1亿的库是如何判断JS类型的？</a>
          </li>
        
          <li>
            <a href="/my-blog/2022/11/10/weekly/10/">明远视角：前端脚手架开发入门</a>
          </li>
        
          <li>
            <a href="/my-blog/2022/11/09/JavaScript/%E4%BD%BF%E7%94%A8%20npm%20link%20%E8%B0%83%E8%AF%95%E5%8C%85/">使用 npm link 调试包</a>
          </li>
        
          <li>
            <a href="/my-blog/2022/11/05/JavaScript/JavaScript%20%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%A7%E6%89%BF/">JavaScript 的对象与继承</a>
          </li>
        
          <li>
            <a href="/my-blog/2022/11/04/JavaScript/%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6/">可选链运算符</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 MingYuan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/my-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/my-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/my-blog/js/jquery-3.4.1.min.js"></script>



  
<script src="/my-blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/my-blog/js/script.js"></script>





  </div>
</body>
</html>